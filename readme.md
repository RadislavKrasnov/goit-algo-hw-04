```
Test Case              | timsort         | insertion_sort  | merge_sort_algo
----------------------------------------------------------------------------
random_data            | 0.000084        | 0.006169        | 0.001695       
accesnding_sorted_data | 0.000004        | 0.005856        | 0.001370       
descending_sorted_data | 0.000004        | 0.005179        | 0.001431       
parially_sorted_data   | 0.000040        | 0.005509        | 0.001511       
duplicated_data        | 0.000049        | 0.004109        | 0.001522       
large_range_data       | 0.000078        | 0.006053        | 0.001648       
10                     | 0.000000        | 0.000008        | 0.000009       
100                    | 0.000005        | 0.000152        | 0.000119       
100_000                | 0.014491        | 103.470464      | 0.270179
```


```
Agorithm                 | Time Complexity                             | Space Complexity
------------------------------------------------------------------------------------------
                         | Best          | Average       | Worst       | Worst
------------------------------------------------------------------------------------------                  
timsort                  |   O(n)        |   O(n log(n)) | O(n log(n)) | O(n)
------------------------------------------------------------------------------------------
binary insertion sort    |   O(n log(n)) |   O(n^2)      | O(n^2)      | O(1)
------------------------------------------------------------------------------------------
merge sort               |   O(n log(n)) |   O(n log(n)) | O(n log(n)) | O(n)
```
# Висновки

### Timsort
Одже ми бачемо, що Timsort є дуже потужним алгоритмом. Він чудово працює на всіх видах даних: відсортованих, несортованих, частково сортованих.  
Також достить швидко обробляє великі набори даних.  
Серед 3-х представлених алгоритмів він є найбільш швидким.  
Така робота Timsort пояснюється його реалізацією.  
Справа в тому, що в середені він використовує Binary Insertion Sort, та Merge Sort.  
Але він не просто їх в середені викликає, цей алгоритм використовує певну стратегію.  
Спочатку він ділить всі дані на малі подмасиви. Ділить він за принципом вже частково відсортованого масиву.  
Тобто він знаходить проміжки даних де значення спадають, або зростають та ділить ці проміжки на підмасиви.  
Далі за допомогою Inserton Sort ці невеликі піднабори сортуються Insertion Sort.   
Insertion Sort досить добре працює на невеликих наборах даних, тому сортування відбувається швидко.  
Далі підмасиви мерджаться та сортуються. Частково відсортовані масиви досить швидко сортуються за   
допомогою Merge Sort. Тобто цей аглоритм приводить дані до такого вигляду, коли можна використовувати сильні сторони  
обох алгоритмів - погано відсортований масив розбивається на малі підмасиви, які швидко сортуються Insertion Sort,  
а потім добре відсортовані підмасиви швидко мерджаться.  
До тогож, деякі реалізації Timsort агоритму мерджаться оптимізовано, через використання "стрибків" (анг. galloping).  
Замість звіряти A[0] і B[0] один з одним, Timsort виконує пошук відповідної позиції b[0] в a[0]. Таким чином, Timsort може повністю перемістити A.   
Потім Timsort шукає відповідне місце A[0] в B. Після цього Timsort також може повністю переміщає B.  
Тобто мердж робиться набагато швидве.  

### Binary Insertion Sort
Як ми бачемо, що Binary Insertion Sort гарно працює на меленькому наборі даних, та дуже погано на великому.  
Найкращі результати цей алгоритм дає на відсортованому, або частково відсортованому масиві.  
Найгірше працює на повністю рандомних масивах значень.  
За теоретичною оцінкою найгірший випадок - це коли початковий масив відсортований у спадаючому порядку.  
Найкращий - коли початковий масив у зростаючому порятду.  
Але на тестах бачемо, що в даному випадку значної різниці між зростаючим та спадаючим почтаковим масивами немає.  
У цьому алгоритмі ми ділимо масив на два підмасиви — відсортований і невідсортований. Перший елемент масиву знаходиться у відсортованому підмасиві,  
а решта елементів – у невідсортованому.  
Потім ми повторюємо від другого елемента до останнього. Для i-ї ітерації ми робимо поточний елемент нашим «ключем».   
Цей ключ є елементом, який ми маємо додати до нашого існуючого відсортованого підмасиву.  
Щоб зробити це, ми спочатку використовуємо двійковий пошук у відсортованому підмасиві,  
щоб знайти позицію елемента, яка трохи перевищує наш ключ.  
Назвемо цю позицію «pos». Потім ми зміщуємо праворуч усі елементи з позиції pos до i-1, а потім робимо Array[pos] = key.  
Можна зауважити, що для кожної i-ї ітерації ліва частина масиву до (i-1) завжди сортується.

### Merge Sort
Піля проведеного тестування ми бачемо, що цей алгоритм добре працює як на малих, так і на великих масивах даних.  
Найкращє працює на відсортованому у зростаючому порядку масиві. Найгірше, коли маємо рандомний порядок значень.  
Цей алгорим працює на підходом Divide and conquer. Він розділяє список рекурсивно на дві половини, поки його більше не можна буде розділити.  
Кожен підмасив сортується окремо за допомогою алгоритму сортування злиттям.  
Відсортовані підмасиви об’єднуються назад у відсортованому порядку.  
Процес триває, доки не буде об’єднано всі елементи з обох підмасивів.
Мінусом цього алгоритму є те, що він потребує додаткового використання пам'яті,  
через зберігання об’єднаних підмасивів під час процесу сортування.

Якщо підбити загальний підсумок, то треба дуже уважно відноситися до написання власних алгоритмів.  
Зазвичай використання вбудованих функцій є більш ефективним, адже вони сильно оптимізовані.  
Як бачемо на прикладі Timsort, цей алгоритм компонує два алгоритми, які використовуються "розумно".  
Тобто кожен починає використовуватися в той момент, коли він є найбільш ефективним.  
Тому Timsort дуже швидкий.  
Але, звичайно, можуть бути ситуації, де написання власних алгоритмів є необхідне.  
